{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Linked Data Classes (oold)","text":"<p>Python toolset for abtract and object oriented access to knowledge graphs. This package aims to implemment this functionality independent from the osw-python package.</p>"},{"location":"#concept","title":"Concept","text":"<p>Illustrative example how the object orient linked data (OOLD) package provides an abstract knowledge graph (KG) interface. First (line 3) primary schemas (Foo) and their dependencies (Bar, Baz) are loaded from the KG and transformed into python dataclasses. Instantiation of foo is handled by loading the respective JSON(-LD) document from the KG and utilizing the type relation to the corresponding schema and dataclass (line 5). Because bar is not a dependent subobject of foo it is loaded on-demand on first access of the corresponding class attribute of foo (foo.bar in line 7), while id as dependent literal is loaded immediately in the same operation. In line 9 baz is constructed by an existing controller class subclassing Foo and finally stored as a new entity in the KG in line 11.</p>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre>"},{"location":"oold/","title":"Oold","text":"<p>LinkedBaseModel Class</p>"},{"location":"oold/#linkedbasemodel","title":"LinkedBaseModel","text":"Source code in <code>src/oold/model/static.py</code> <pre><code>class GenericLinkedBaseModel:\n    pass\n</code></pre>"},{"location":"oold/#linkedbasemodel-v1","title":"LinkedBaseModel v1","text":"<p>               Bases: <code>BaseModel</code>, <code>GenericLinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v1</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>class LinkedBaseModel(\n    BaseModel, GenericLinkedBaseModel, metaclass=LinkedBaseModelMetaClass\n):\n    \"\"\"LinkedBaseModel for pydantic v1\"\"\"\n\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = PrivateAttr()\n\n    def get_iri(self) -&gt; str:\n        \"\"\"Return the unique IRI of the object.\n        Overwrite this method in the subclass.\"\"\"\n        return self.id\n\n    @classmethod\n    def parse_obj(cls, obj: Any) -&gt; \"LinkedBaseModel\":\n        \"\"\"Parse the object and return a LinkedBaseModel instance.\n        This method is called by pydantic when creating\n        a new (default) instance of the model.\"\"\"\n        if isinstance(obj, str):\n            # pydantic v1\n            return cls._resolve([obj])[obj]\n        if isinstance(obj, list):\n            # pydantic v1\n            # return cls._resolve(obj).nodes[obj[0]]\n            node_dict = cls._resolve(obj)\n            node_list = []\n            for iri in obj:\n                node = node_dict[iri]\n                if node:\n                    node_list.append(node)\n            return node_list\n        elif isinstance(obj, dict):\n            return super().parse_obj(obj)\n\n    def __init__(self, *a, **kw):\n        if \"__iris__\" not in kw:\n            kw[\"__iris__\"] = {}\n\n        for name in list(kw):  # force copy of keys for inline-delete\n            # print(name)\n            if name == \"__iris__\":\n                continue\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            if name in self.__fields__:\n                if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                    extra = self.__fields__[name].default.json_schema_extra\n                elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                    extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            # extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        kw[name] = None  # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].get_iri()\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        kw[name] = None  # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n\n        BaseModel.__init__(self, *a, **kw)\n        # handle default values\n        for name in list(self.__dict__.keys()):\n            if self.__dict__[name] is None:\n                continue\n            extra = None\n            # pydantic v1\n            if name in self.__fields__:\n                if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                    extra = self.__fields__[name].default.json_schema_extra\n                elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                    extra = self.__fields__[name].field_info.extra\n            if extra and \"range\" in extra and name not in kw[\"__iris__\"]:\n                arg_is_list = isinstance(self.__dict__[name], list)\n\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in self.__dict__[name]:\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                else:\n                    # contructed with object ref\n                    if isinstance(self.__dict__[name], BaseModel):\n                        kw[\"__iris__\"][name] = self.__dict__[name].get_iri()\n\n        self.__iris__ = kw[\"__iris__\"]\n\n    def __getattribute__(self, name):\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node)\n\n        return BaseModel.__getattribute__(self, name)\n\n    def _object_to_iri(self, d):\n        for name in list(d.keys()):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n                # del d[name + \"_iri\"]\n        return d\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        # print(\"dict\")\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        # pprint(d)\n        return d\n\n    @staticmethod\n    def _resolve(iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v1\n    def json(\n        self,\n        *,\n        include: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n        exclude: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n        by_alias: bool = False,\n        skip_defaults: Optional[bool] = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        encoder: Optional[Callable[[Any], Any]] = None,\n        models_as_dict: bool = True,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"\n        Generate a JSON representation of the model,\n        `include` and `exclude` arguments as per `dict()`.\n\n        `encoder` is an optional function to supply as `default` to json.dumps(),\n        other arguments as per `json.dumps()`.\n        \"\"\"\n        d = json.loads(\n            BaseModel.json(\n                self,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                skip_defaults=skip_defaults,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                encoder=encoder,\n                models_as_dict=models_as_dict,\n                **dumps_kwargs,\n            )\n        )  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **dumps_kwargs)\n\n    def to_jsonld(self) -&gt; Dict:\n        \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n        return export_jsonld(self, BaseModel)\n\n    @classmethod\n    def from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n        \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n        return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.from_jsonld","title":"<code>from_jsonld(jsonld)</code>  <code>classmethod</code>","text":"<p>Constructs a model instance from a JSON-LD representation.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>@classmethod\ndef from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n    \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n    return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.get_iri","title":"<code>get_iri()</code>","text":"<p>Return the unique IRI of the object. Overwrite this method in the subclass.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def get_iri(self) -&gt; str:\n    \"\"\"Return the unique IRI of the object.\n    Overwrite this method in the subclass.\"\"\"\n    return self.id\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.json","title":"<code>json(*, include=None, exclude=None, by_alias=False, skip_defaults=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=None, models_as_dict=True, **dumps_kwargs)</code>","text":"<p>Generate a JSON representation of the model, <code>include</code> and <code>exclude</code> arguments as per <code>dict()</code>.</p> <p><code>encoder</code> is an optional function to supply as <code>default</code> to json.dumps(), other arguments as per <code>json.dumps()</code>.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def json(\n    self,\n    *,\n    include: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n    exclude: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n    by_alias: bool = False,\n    skip_defaults: Optional[bool] = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Optional[Callable[[Any], Any]] = None,\n    models_as_dict: bool = True,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"\n    Generate a JSON representation of the model,\n    `include` and `exclude` arguments as per `dict()`.\n\n    `encoder` is an optional function to supply as `default` to json.dumps(),\n    other arguments as per `json.dumps()`.\n    \"\"\"\n    d = json.loads(\n        BaseModel.json(\n            self,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            encoder=encoder,\n            models_as_dict=models_as_dict,\n            **dumps_kwargs,\n        )\n    )  # ToDo directly use dict?\n    self._object_to_iri(d)\n    return json.dumps(d, **dumps_kwargs)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Parse the object and return a LinkedBaseModel instance. This method is called by pydantic when creating a new (default) instance of the model.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>@classmethod\ndef parse_obj(cls, obj: Any) -&gt; \"LinkedBaseModel\":\n    \"\"\"Parse the object and return a LinkedBaseModel instance.\n    This method is called by pydantic when creating\n    a new (default) instance of the model.\"\"\"\n    if isinstance(obj, str):\n        # pydantic v1\n        return cls._resolve([obj])[obj]\n    if isinstance(obj, list):\n        # pydantic v1\n        # return cls._resolve(obj).nodes[obj[0]]\n        node_dict = cls._resolve(obj)\n        node_list = []\n        for iri in obj:\n            node = node_dict[iri]\n            if node:\n                node_list.append(node)\n        return node_list\n    elif isinstance(obj, dict):\n        return super().parse_obj(obj)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.to_jsonld","title":"<code>to_jsonld()</code>","text":"<p>Return the RDF representation of the object as JSON-LD.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def to_jsonld(self) -&gt; Dict:\n    \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n    return export_jsonld(self, BaseModel)\n</code></pre>"},{"location":"oold/#linkedbasemodel-v2","title":"LinkedBaseModel v2","text":"<p>               Bases: <code>BaseModel</code>, <code>GenericLinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v2</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>class LinkedBaseModel(\n    BaseModel, GenericLinkedBaseModel, metaclass=LinkedBaseModelMetaClass\n):\n    \"\"\"LinkedBaseModel for pydantic v2\"\"\"\n\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = {}\n\n    def get_iri(self) -&gt; str:\n        \"\"\"Return the unique IRI of the object.\n        Overwrite this method in the subclass.\"\"\"\n        return self.id\n\n    def __init__(self, *a, **kw):\n        if \"__iris__\" not in kw:\n            kw[\"__iris__\"] = {}\n\n        for name in list(kw):  # force copy of keys for inline-delete\n            if name == \"__iris__\":\n                continue\n            if name not in self.model_fields:\n                continue\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            # if name in self.__fields__:\n            #     if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n            #         extra = self.__fields__[name].default.json_schema_extra\n            #     elif hasattr(self.__fields__[name].field_info, \"extra\"):\n            #         extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        del kw[name]\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].get_iri()\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        del kw[name]\n\n        BaseModel.__init__(self, *a, **kw)\n\n        self.__iris__ = kw[\"__iris__\"]\n\n    def __getattribute__(self, name):\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node)\n\n        return BaseModel.__getattribute__(self, name)\n\n    def _object_to_iri(self, d):\n        for name in list(d.keys()):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n                # del d[name + \"_iri\"]\n        return d\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        # print(\"dict\")\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        # pprint(d)\n        return d\n\n    def _resolve(self, iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v2\n    def model_dump_json(\n        self,\n        *,\n        indent: Union[int, None] = None,\n        include: Union[pydantic.main.IncEx, None] = None,\n        exclude: Union[pydantic.main.IncEx, None] = None,\n        context: Union[Any, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: Union[bool, Literal[\"none\", \"warn\", \"error\"]] = True,\n        serialize_as_any: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"Usage docs:\n        https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\n        Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n        Args:\n            indent: Indentation to use in the JSON output.\n                If None is passed, the output will be compact.\n            include: Field(s) to include in the JSON output.\n            exclude: Field(s) to exclude from the JSON output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to serialize using field aliases.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to\n                their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            round_trip: If True, dumped values should be valid as input\n                for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them,\n                True/\"warn\" logs errors, \"error\" raises a\n                [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization\n                behavior.\n\n        Returns:\n            A JSON string representation of the model.\n        \"\"\"\n        d = json.loads(\n            BaseModel.model_dump_json(\n                self,\n                indent=indent,\n                include=include,\n                exclude=exclude,\n                context=context,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                round_trip=round_trip,\n                warnings=warnings,\n                serialize_as_any=serialize_as_any,\n            )\n        )  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **dumps_kwargs)\n\n    def to_jsonld(self) -&gt; Dict:\n        \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n        return export_jsonld(self, BaseModel)\n\n    @classmethod\n    def from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n        \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n        return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.from_jsonld","title":"<code>from_jsonld(jsonld)</code>  <code>classmethod</code>","text":"<p>Constructs a model instance from a JSON-LD representation.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>@classmethod\ndef from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n    \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n    return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.get_iri","title":"<code>get_iri()</code>","text":"<p>Return the unique IRI of the object. Overwrite this method in the subclass.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def get_iri(self) -&gt; str:\n    \"\"\"Return the unique IRI of the object.\n    Overwrite this method in the subclass.\"\"\"\n    return self.id\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.model_dump_json","title":"<code>model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, serialize_as_any=False, **dumps_kwargs)</code>","text":"<p>Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Args:     indent: Indentation to use in the JSON output.         If None is passed, the output will be compact.     include: Field(s) to include in the JSON output.     exclude: Field(s) to exclude from the JSON output.     context: Additional context to pass to the serializer.     by_alias: Whether to serialize using field aliases.     exclude_unset: Whether to exclude fields that have not been explicitly set.     exclude_defaults: Whether to exclude fields that are set to         their default value.     exclude_none: Whether to exclude fields that have a value of <code>None</code>.     round_trip: If True, dumped values should be valid as input         for non-idempotent types such as Json[T].     warnings: How to handle serialization errors. False/\"none\" ignores them,         True/\"warn\" logs errors, \"error\" raises a         [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError].     serialize_as_any: Whether to serialize fields with duck-typing serialization         behavior.</p> <p>Returns:     A JSON string representation of the model.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: Union[int, None] = None,\n    include: Union[pydantic.main.IncEx, None] = None,\n    exclude: Union[pydantic.main.IncEx, None] = None,\n    context: Union[Any, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    warnings: Union[bool, Literal[\"none\", \"warn\", \"error\"]] = True,\n    serialize_as_any: bool = False,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"Usage docs:\n    https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output.\n            If None is passed, the output will be compact.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to\n            their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        round_trip: If True, dumped values should be valid as input\n            for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them,\n            True/\"warn\" logs errors, \"error\" raises a\n            [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        serialize_as_any: Whether to serialize fields with duck-typing serialization\n            behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    d = json.loads(\n        BaseModel.model_dump_json(\n            self,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            context=context,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n        )\n    )  # ToDo directly use dict?\n    self._object_to_iri(d)\n    return json.dumps(d, **dumps_kwargs)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.to_jsonld","title":"<code>to_jsonld()</code>","text":"<p>Return the RDF representation of the object as JSON-LD.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def to_jsonld(self) -&gt; Dict:\n    \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n    return export_jsonld(self, BaseModel)\n</code></pre>"}]}