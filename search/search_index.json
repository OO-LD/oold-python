{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Linked Data Classes (LDC)","text":"<p>Python toolset for abtract and object oriented access to knowledge graphs</p>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre>"},{"location":"ldc/","title":"Ldc","text":"<p>LinkedBaseModel Class</p>"},{"location":"ldc/#linkedbasemodel","title":"LinkedBaseModel","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/ldc/model/static.py</code> <pre><code>class LinkedBaseModel(BaseModel):\n    resolver: Resolver\n    type: str\n    id: str\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = {}\n\n    def __init__(self, *a, **kw):\n        # pprint(a)\n        # pprint(kw)\n        for name in list(kw):  # force copy of keys for inline-delete\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            # if hasattr(self.__fields__[name], \"extra\")\n            # and \"range\" in self.__fields__[name].extra: # pydantic v1\n            if \"__iris__\" not in kw:\n                kw[\"__iris__\"] = {}\n            if (\n                self.model_fields[name].json_schema_extra\n                and \"range\" in self.model_fields[name].json_schema_extra\n            ):  # pydantic v2: model_fields\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.id)\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].id\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        del kw[name]\n        pprint(kw)\n        super().__init__(*a, **kw)\n        self.__iris__ = kw[\"__iris__\"]\n\n    def __getattribute__(self, name):\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n        # if name in [\"__pydantic_extra__\"]\n        if \"__iris__\" in self.__dict__:\n            if name in self.__dict__[\"__iris__\"]:\n                if self.__dict__[name] is None or (\n                    isinstance(self.__dict__[name], list)\n                    and len(self.__dict__[name]) == 0\n                ):\n                    iris = self.__iris__[name]\n                    is_list = isinstance(iris, list)\n                    if not is_list:\n                        iris = [iris]\n                    node_dict = self.resolver.resolve(ResolveRequest(iris=iris)).nodes\n                    if is_list:\n                        node_list = []\n                        for iri in iris:\n                            node = node_dict[iris[0]]\n                            node_list.append(node)\n                        self.__setattr__(name, node_list)\n                    else:\n                        node = node_dict[iris[0]]\n                        if node:\n                            self.__setattr__(name, node)\n        return BaseModel.__getattribute__(self, name)\n\n    def _object_to_iri(self, d):\n        for name in list(d):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n                # del d[name + \"_iri\"]\n        return d\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        print(\"dict\")\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        # pprint(d)\n        return d\n\n    def json(self, **kwargs):\n        print(\"json\")\n        d = json.loads(BaseModel.json(self, **kwargs))  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **kwargs)\n\n    def model_dump_json(self, **kwargs):\n        print(\"json\")\n        d = json.loads(\n            BaseModel.model_dump_json(self, **kwargs)\n        )  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **kwargs)\n</code></pre>"}]}