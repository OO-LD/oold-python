{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Linked Data Classes (oold)","text":"<p>Python toolset for abtract and object oriented access to knowledge graphs. This package aims to implemment this functionality independent from the osw-python package.</p>"},{"location":"#concept","title":"Concept","text":"<p>Illustrative example how the object orient linked data (OOLD) package provides an abstract knowledge graph (KG) interface. First (line 3) primary schemas (Foo) and their dependencies (Bar, Baz) are loaded from the KG and transformed into python dataclasses. Instantiation of foo is handled by loading the respective JSON(-LD) document from the KG and utilizing the type relation to the corresponding schema and dataclass (line 5). Because bar is not a dependent subobject of foo it is loaded on-demand on first access of the corresponding class attribute of foo (foo.bar in line 7), while id as dependent literal is loaded immediately in the same operation. In line 9 baz is constructed by an existing controller class subclassing Foo and finally stored as a new entity in the KG in line 11.</p>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre>"},{"location":"oold/","title":"Oold","text":"<p>LinkedBaseModel Class</p>"},{"location":"oold/#linkedbasemodel","title":"LinkedBaseModel","text":"Source code in <code>src/oold/model/static.py</code> <pre><code>class GenericLinkedBaseModel():\n    pass\n</code></pre>"},{"location":"oold/#linkedbasemodel-v1","title":"LinkedBaseModel v1","text":"<p>               Bases: <code>BaseModel</code>, <code>GenericLinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v1</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>class LinkedBaseModel(BaseModel, GenericLinkedBaseModel):\n    \"\"\"LinkedBaseModel for pydantic v1\"\"\"\n    id: str\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = PrivateAttr()\n\n    def __init__(self, *a, **kw):\n        for name in list(kw):  # force copy of keys for inline-delete\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                extra = self.__fields__[name].default.json_schema_extra\n            # pydantic v2\n            # extra = self.model_fields[name].json_schema_extra\n            if \"__iris__\" not in kw:\n                kw[\"__iris__\"] = {}\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.id)\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].id\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n\n\n        BaseModel.__init__(self, *a, **kw)\n\n        self.__iris__ = kw[\"__iris__\"]\n\n    def __getattribute__(self, name):\n\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node)\n\n        return BaseModel.__getattribute__(self, name)\n\n\n    def _object_to_iri(self, d):\n        for name in list(d):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n                # del d[name + \"_iri\"]\n        return d\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        print(\"dict\")\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        # pprint(d)\n        return d\n\n    def _resolve(self, iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v1\n    def json(self, **kwargs):\n        print(\"json\")\n        d = json.loads(BaseModel.json(self, **kwargs))  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **kwargs)\n</code></pre>"},{"location":"oold/#linkedbasemodel-v2","title":"LinkedBaseModel v2","text":"<p>               Bases: <code>BaseModel</code>, <code>GenericLinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v1</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>class LinkedBaseModel(BaseModel, GenericLinkedBaseModel):\n    \"\"\"LinkedBaseModel for pydantic v1\"\"\"\n    id: str\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = {}\n\n    def __init__(self, *a, **kw):\n        for name in list(kw):  # force copy of keys for inline-delete\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            #if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n            #    extra = self.__fields__[name].default.json_schema_extra\n            # pydantic v2\n            extra = self.model_fields[name].json_schema_extra\n            if \"__iris__\" not in kw:\n                kw[\"__iris__\"] = {}\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.id)\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        del kw[name]\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].id\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        del kw[name]\n\n\n        BaseModel.__init__(self, *a, **kw)\n\n        self.__iris__ = kw[\"__iris__\"]\n\n    def __getattribute__(self, name):\n\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node)\n\n        return BaseModel.__getattribute__(self, name)\n\n\n    def _object_to_iri(self, d):\n        for name in list(d):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n                # del d[name + \"_iri\"]\n        return d\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        print(\"dict\")\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        # pprint(d)\n        return d\n\n    def _resolve(self, iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v2\n    def model_dump_json(self, **kwargs):\n        print(\"json\")\n        d = json.loads(\n            BaseModel.model_dump_json(self, **kwargs)\n        )  # ToDo directly use dict?\n        self._object_to_iri(d)\n        return json.dumps(d, **kwargs)\n</code></pre>"}]}