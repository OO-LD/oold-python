{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Linked Data Classes (oold)","text":"<p>Python toolset for abtract and object oriented access to knowledge graphs. This package aims to implemment this functionality independent from the osw-python package.</p>"},{"location":"#concept","title":"Concept","text":"<p>Illustrative example how the object orient linked data (OOLD) package provides an abstract knowledge graph (KG) interface. First (line 3) primary schemas (Foo) and their dependencies (Bar, Baz) are loaded from the KG and transformed into python dataclasses. Instantiation of foo is handled by loading the respective JSON(-LD) document from the KG and utilizing the type relation to the corresponding schema and dataclass (line 5). Because bar is not a dependent subobject of foo it is loaded on-demand on first access of the corresponding class attribute of foo (foo.bar in line 7), while id as dependent literal is loaded immediately in the same operation. In line 9 baz is constructed by an existing controller class subclassing Foo and finally stored as a new entity in the KG in line 11.</p>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre>"},{"location":"oold/","title":"Oold","text":"<p>LinkedBaseModel Class</p>"},{"location":"oold/#linkedbasemodel","title":"LinkedBaseModel","text":"Source code in <code>src/oold/model/static.py</code> <pre><code>class GenericLinkedBaseModel:\n    def _object_to_iri(self, d, exclude_none=False):\n        for name in list(d.keys()):  # force copy of keys for inline-delete\n            if name in self.__iris__:\n                d[name] = self.__iris__[name]\n            if exclude_none and d[name] is None:\n                del d[name]\n        return d\n\n    @staticmethod\n    def remove_none(d: Dict) -&gt; Dict:\n        \"\"\"Remove None values from a dictionary recursively.\"\"\"\n        if isinstance(d, dict):\n            return {\n                k: GenericLinkedBaseModel.remove_none(v)\n                for k, v in d.items()\n                if v is not None\n            }\n        elif isinstance(d, list):\n            return [GenericLinkedBaseModel.remove_none(i) for i in d]\n        else:\n            return d\n\n    @classmethod\n    def export_schema(\n        cls,\n        mode: Optional[SchemaExportMode] = SchemaExportMode.FULL,\n        cutoff_base_cls: Optional[\n            Union[Union[BaseModel, BaseModel_v1], Tuple[Union[BaseModel, BaseModel_v1]]]\n        ] = None,\n        partial_mode: Optional[\n            PartialSchemaExportMode\n        ] = PartialSchemaExportMode.BASE_CLASS_CUTOFF,\n    ) -&gt; Dict:\n        \"\"\"Export the schema of the model as a dictionary.\"\"\"\n        return export_schema(cls, mode, cutoff_base_cls, partial_mode)\n</code></pre>"},{"location":"oold/#oold.model.static.GenericLinkedBaseModel.export_schema","title":"<code>export_schema(mode=SchemaExportMode.FULL, cutoff_base_cls=None, partial_mode=PartialSchemaExportMode.BASE_CLASS_CUTOFF)</code>  <code>classmethod</code>","text":"<p>Export the schema of the model as a dictionary.</p> Source code in <code>src/oold/model/static.py</code> <pre><code>@classmethod\ndef export_schema(\n    cls,\n    mode: Optional[SchemaExportMode] = SchemaExportMode.FULL,\n    cutoff_base_cls: Optional[\n        Union[Union[BaseModel, BaseModel_v1], Tuple[Union[BaseModel, BaseModel_v1]]]\n    ] = None,\n    partial_mode: Optional[\n        PartialSchemaExportMode\n    ] = PartialSchemaExportMode.BASE_CLASS_CUTOFF,\n) -&gt; Dict:\n    \"\"\"Export the schema of the model as a dictionary.\"\"\"\n    return export_schema(cls, mode, cutoff_base_cls, partial_mode)\n</code></pre>"},{"location":"oold/#oold.model.static.GenericLinkedBaseModel.remove_none","title":"<code>remove_none(d)</code>  <code>staticmethod</code>","text":"<p>Remove None values from a dictionary recursively.</p> Source code in <code>src/oold/model/static.py</code> <pre><code>@staticmethod\ndef remove_none(d: Dict) -&gt; Dict:\n    \"\"\"Remove None values from a dictionary recursively.\"\"\"\n    if isinstance(d, dict):\n        return {\n            k: GenericLinkedBaseModel.remove_none(v)\n            for k, v in d.items()\n            if v is not None\n        }\n    elif isinstance(d, list):\n        return [GenericLinkedBaseModel.remove_none(i) for i in d]\n    else:\n        return d\n</code></pre>"},{"location":"oold/#linkedbasemodel-v1","title":"LinkedBaseModel v1","text":"<p>               Bases: <code>_LinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v1</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>class LinkedBaseModel(_LinkedBaseModel):\n    \"\"\"LinkedBaseModel for pydantic v1\"\"\"\n\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = PrivateAttr()\n\n    def get_iri(self) -&gt; str:\n        \"\"\"Return the unique IRI of the object.\n        Overwrite this method in the subclass.\"\"\"\n        return self.id\n\n    @classmethod\n    def parse_obj(cls, obj: Any) -&gt; \"LinkedBaseModel\":\n        \"\"\"Parse the object and return a LinkedBaseModel instance.\n        This method is called by pydantic when creating\n        a new (default) instance of the model.\"\"\"\n        if isinstance(obj, str):\n            # pydantic v1\n            return cls._resolve([obj])[obj]\n        if isinstance(obj, list):\n            # pydantic v1\n            # return cls._resolve(obj).nodes[obj[0]]\n            node_dict = cls._resolve(obj)\n            node_list = []\n            for iri in obj:\n                node = node_dict[iri]\n                if node:\n                    node_list.append(node)\n            return node_list\n        elif isinstance(obj, dict):\n            return super().parse_obj(obj)\n\n    def __init__(self, *a, **kw):\n        if \"__iris__\" not in kw:\n            kw[\"__iris__\"] = {}\n\n        for name in list(kw):  # force copy of keys for inline-delete\n            # print(name)\n            if name == \"__iris__\":\n                continue\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            if name in self.__fields__:\n                if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                    extra = self.__fields__[name].default.json_schema_extra\n                elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                    extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            # extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        kw[name] = None  # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].get_iri()\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        kw[name] = None  # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        # del kw[name]\n\n        BaseModel.__init__(self, *a, **kw)\n        # handle default values\n        for name in list(self.__dict__.keys()):\n            if self.__dict__[name] is None:\n                continue\n            extra = None\n            # pydantic v1\n            if name in self.__fields__:\n                if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                    extra = self.__fields__[name].default.json_schema_extra\n                elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                    extra = self.__fields__[name].field_info.extra\n            if extra and \"range\" in extra and name not in kw[\"__iris__\"]:\n                arg_is_list = isinstance(self.__dict__[name], list)\n\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in self.__dict__[name]:\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                else:\n                    # contructed with object ref\n                    if isinstance(self.__dict__[name], BaseModel):\n                        kw[\"__iris__\"][name] = self.__dict__[name].get_iri()\n\n        self.__iris__ = kw[\"__iris__\"]\n\n        # iterate over all fields\n        # if x-oold-required-iri occurs in extra and the field is not set in __iri__\n        # throw an error\n        for name in self.__fields__:\n            extra = None\n            # pydantic v1\n            if name in self.__fields__:\n                if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                    extra = self.__fields__[name].default.json_schema_extra\n                elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                    extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            # extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"x_oold_required_iri\" in extra:\n                if name not in self.__iris__:\n                    raise ValueError(f\"{name} is required but not set\")\n\n    def _handle_value(self, name, value):\n        extra = None\n        # pydantic v1\n        if name in self.__fields__:\n            if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n                extra = self.__fields__[name].default.json_schema_extra\n            elif hasattr(self.__fields__[name].field_info, \"extra\"):\n                extra = self.__fields__[name].field_info.extra\n        # pydantic v2\n        # extra = self.model_fields[name].json_schema_extra\n\n        if extra and \"range\" in extra:\n            arg_is_list = isinstance(value, list)\n\n            if arg_is_list:\n                self.__iris__[name] = []\n                for e in value[:]:  # interate over copy of list\n                    if isinstance(e, BaseModel):  # contructed with object ref\n                        self.__iris__[name].append(e.get_iri())\n                    elif isinstance(e, str):  # constructed from json\n                        self.__iris__[name].append(e)\n                        value.remove(e)  # remove to construct valid instance\n                if len(value) == 0:\n                    # pydantic v1\n                    value = None  # else pydantic v1 will set a FieldInfo object\n                    # pydantic v2\n                    # del kw[name]\n            else:\n                if isinstance(value, BaseModel):  # contructed with object ref\n                    # print(value.id)\n                    self.__iris__[name] = value.get_iri()\n                elif isinstance(value, str):  # constructed from json\n                    self.__iris__[name] = value\n                    # pydantic v1\n                    value = None  # else pydantic v1 will set a FieldInfo object\n                    # pydantic v2\n                    # del kw[name]\n                elif value is None:\n                    del self.__iris__[name]\n        return value\n\n    def __setattr__(self, name, value, internal=False):\n        # print(\"__setattr__\", name, value)\n        if not internal and name not in [\n            \"__dict__\",\n            \"__pydantic_private__\",\n            \"__iris__\",\n        ]:\n            value = self._handle_value(name, value)\n\n        return super().__setattr__(name, value)\n\n    def __getattribute__(self, name):\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__ and len(self.__iris__[name]) &gt; 0:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list, True)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node, True)\n\n        return BaseModel.__getattribute__(self, name)\n\n    def dict(self, **kwargs):  # extent BaseClass export function\n        # print(\"dict\")\n        remove_none = kwargs.get(\"exclude_none\", False)\n        kwargs[\"exclude_none\"] = False\n        d = super().dict(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        if remove_none:\n            d = self.remove_none(d)\n        # pprint(d)\n        return d\n\n    @staticmethod\n    def _resolve(iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v1\n    def json(\n        self,\n        *,\n        include: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n        exclude: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n        by_alias: bool = False,\n        skip_defaults: Optional[bool] = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        encoder: Optional[Callable[[Any], Any]] = None,\n        models_as_dict: bool = True,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"\n        Generate a JSON representation of the model,\n        `include` and `exclude` arguments as per `dict()`.\n\n        `encoder` is an optional function to supply as `default` to json.dumps(),\n        other arguments as per `json.dumps()`.\n        \"\"\"\n        d = json.loads(\n            BaseModel.json(\n                self,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                skip_defaults=skip_defaults,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=False,  # handle None values separately\n                encoder=encoder,\n                models_as_dict=models_as_dict,\n                **dumps_kwargs,\n            )\n        )  # ToDo directly use dict?\n        # this may replace some None values with IRIs in case they were never resolved\n        # thats why we handle exclude_none there\n        self._object_to_iri(d)\n        if exclude_none:\n            d = self.remove_none(d)\n        return json.dumps(d, **dumps_kwargs)\n\n    def to_jsonld(self) -&gt; Dict:\n        \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n        return export_jsonld(self, BaseModel)\n\n    @classmethod\n    def from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n        \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n        return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.from_jsonld","title":"<code>from_jsonld(jsonld)</code>  <code>classmethod</code>","text":"<p>Constructs a model instance from a JSON-LD representation.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>@classmethod\ndef from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n    \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n    return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.get_iri","title":"<code>get_iri()</code>","text":"<p>Return the unique IRI of the object. Overwrite this method in the subclass.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def get_iri(self) -&gt; str:\n    \"\"\"Return the unique IRI of the object.\n    Overwrite this method in the subclass.\"\"\"\n    return self.id\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.json","title":"<code>json(*, include=None, exclude=None, by_alias=False, skip_defaults=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=None, models_as_dict=True, **dumps_kwargs)</code>","text":"<p>Generate a JSON representation of the model, <code>include</code> and <code>exclude</code> arguments as per <code>dict()</code>.</p> <p><code>encoder</code> is an optional function to supply as <code>default</code> to json.dumps(), other arguments as per <code>json.dumps()</code>.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def json(\n    self,\n    *,\n    include: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n    exclude: Optional[Union[\"AbstractSetIntStr\", \"MappingIntStrAny\"]] = None,\n    by_alias: bool = False,\n    skip_defaults: Optional[bool] = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    encoder: Optional[Callable[[Any], Any]] = None,\n    models_as_dict: bool = True,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"\n    Generate a JSON representation of the model,\n    `include` and `exclude` arguments as per `dict()`.\n\n    `encoder` is an optional function to supply as `default` to json.dumps(),\n    other arguments as per `json.dumps()`.\n    \"\"\"\n    d = json.loads(\n        BaseModel.json(\n            self,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=False,  # handle None values separately\n            encoder=encoder,\n            models_as_dict=models_as_dict,\n            **dumps_kwargs,\n        )\n    )  # ToDo directly use dict?\n    # this may replace some None values with IRIs in case they were never resolved\n    # thats why we handle exclude_none there\n    self._object_to_iri(d)\n    if exclude_none:\n        d = self.remove_none(d)\n    return json.dumps(d, **dumps_kwargs)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Parse the object and return a LinkedBaseModel instance. This method is called by pydantic when creating a new (default) instance of the model.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>@classmethod\ndef parse_obj(cls, obj: Any) -&gt; \"LinkedBaseModel\":\n    \"\"\"Parse the object and return a LinkedBaseModel instance.\n    This method is called by pydantic when creating\n    a new (default) instance of the model.\"\"\"\n    if isinstance(obj, str):\n        # pydantic v1\n        return cls._resolve([obj])[obj]\n    if isinstance(obj, list):\n        # pydantic v1\n        # return cls._resolve(obj).nodes[obj[0]]\n        node_dict = cls._resolve(obj)\n        node_list = []\n        for iri in obj:\n            node = node_dict[iri]\n            if node:\n                node_list.append(node)\n        return node_list\n    elif isinstance(obj, dict):\n        return super().parse_obj(obj)\n</code></pre>"},{"location":"oold/#oold.model.v1.LinkedBaseModel.to_jsonld","title":"<code>to_jsonld()</code>","text":"<p>Return the RDF representation of the object as JSON-LD.</p> Source code in <code>src/oold/model/v1/__init__.py</code> <pre><code>def to_jsonld(self) -&gt; Dict:\n    \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n    return export_jsonld(self, BaseModel)\n</code></pre>"},{"location":"oold/#linkedbasemodel-v2","title":"LinkedBaseModel v2","text":"<p>               Bases: <code>_LinkedBaseModel</code></p> <p>LinkedBaseModel for pydantic v2</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>class LinkedBaseModel(_LinkedBaseModel):\n    \"\"\"LinkedBaseModel for pydantic v2\"\"\"\n\n    __iris__: Optional[Dict[str, Union[str, List[str]]]] = {}\n\n    def get_iri(self) -&gt; str:\n        \"\"\"Return the unique IRI of the object.\n        Overwrite this method in the subclass.\"\"\"\n        return self.id\n\n    @classmethod\n    def model_validate(\n        cls,\n        obj: Any,\n        *,\n        strict: Union[bool, None] = None,\n        from_attributes: Union[bool, None] = None,\n        context: Union[Any, None] = None,\n    ) -&gt; Self:\n        \"\"\"Validate a pydantic model instance.\n\n        Args:\n            obj: The object to validate.\n            strict: Whether to enforce types strictly.\n            from_attributes: Whether to extract data from object attributes.\n            context: Additional context to pass to the validator.\n\n        Raises:\n            ValidationError: If the object could not be validated.\n\n        Returns:\n            The validated model instance.\n        \"\"\"\n        if isinstance(obj, str):\n            return cls._resolve([obj])[obj]\n        if isinstance(obj, list):\n            node_dict = cls._resolve(obj)\n            node_list = []\n            for iri in obj:\n                node = node_dict[iri]\n                if node:\n                    node_list.append(node)\n            return node_list\n        elif isinstance(obj, dict):\n            super().model_validate(\n                obj, strict=strict, from_attributes=from_attributes, context=context\n            )\n\n    def __init__(self, *a, **kw):\n        if \"__iris__\" not in kw:\n            kw[\"__iris__\"] = {}\n\n        for name in list(kw):  # force copy of keys for inline-delete\n            if name == \"__iris__\":\n                continue\n            if name not in self.model_fields:\n                continue\n            # rewrite &lt;attr&gt; to &lt;attr&gt;_iri\n            # pprint(self.__fields__)\n            extra = None\n            # pydantic v1\n            # if name in self.__fields__:\n            #     if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n            #         extra = self.__fields__[name].default.json_schema_extra\n            #     elif hasattr(self.__fields__[name].field_info, \"extra\"):\n            #         extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(kw[name], list)\n\n                # annotation_is_list = False\n                # args = self.model_fields[name].annotation.__args__\n                # if hasattr(args[0], \"_name\"):\n                #    is_list = args[0]._name == \"List\"\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in kw[name][:]:  # interate over copy of list\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                        elif isinstance(e, str):  # constructed from json\n                            kw[\"__iris__\"][name].append(e)\n                            kw[name].remove(e)  # remove to construct valid instance\n                    if len(kw[name]) == 0:\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        kw[name] = None  # else default value may be set\n                else:\n                    if isinstance(kw[name], BaseModel):  # contructed with object ref\n                        # print(kw[name].id)\n                        kw[\"__iris__\"][name] = kw[name].get_iri()\n                    elif isinstance(kw[name], str):  # constructed from json\n                        kw[\"__iris__\"][name] = kw[name]\n                        # pydantic v1\n                        # kw[name] = None # else pydantic v1 will set a FieldInfo object\n                        # pydantic v2\n                        kw[name] = None  # else default value may be set\n\n        BaseModel.__init__(self, *a, **kw)\n        # handle default values\n        for name in list(self.__dict__.keys()):\n            if self.__dict__[name] is None:\n                continue\n            extra = None\n            # pydantic v1\n            # if name in self.__fields__:\n            #     if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n            #         extra = self.__fields__[name].default.json_schema_extra\n            #     elif hasattr(self.__fields__[name].field_info, \"extra\"):\n            #         extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"range\" in extra:\n                arg_is_list = isinstance(self.__dict__, list)\n\n                if arg_is_list:\n                    kw[\"__iris__\"][name] = []\n                    for e in self.__dict__[name]:\n                        if isinstance(e, BaseModel):  # contructed with object ref\n                            kw[\"__iris__\"][name].append(e.get_iri())\n                else:\n                    if isinstance(\n                        self.__dict__[name], BaseModel\n                    ):  # contructed with object ref\n                        kw[\"__iris__\"][name] = self.__dict__[name].get_iri()\n\n        self.__iris__ = kw[\"__iris__\"]\n\n        # iterate over all fields\n        # if x-oold-required-iri occurs in extra and the field is not set in __iri__\n        # throw an error\n        for name in self.model_fields:\n            extra = None\n            # pydantic v1\n            # if name in self.__fields__:\n            #     if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n            #         extra = self.__fields__[name].default.json_schema_extra\n            #     elif hasattr(self.__fields__[name].field_info, \"extra\"):\n            #         extra = self.__fields__[name].field_info.extra\n            # pydantic v2\n            extra = self.model_fields[name].json_schema_extra\n\n            if extra and \"x-oold-required-iri\" in extra:\n                if name not in self.__iris__:\n                    raise ValueError(f\"{name} is required but not set\")\n\n    def _handle_value(self, name, value):\n        extra = None\n        # pydantic v1\n        # if name in self.__fields__:\n        #     if hasattr(self.__fields__[name].default, \"json_schema_extra\"):\n        #         extra = self.__fields__[name].default.json_schema_extra\n        #     elif hasattr(self.__fields__[name].field_info, \"extra\"):\n        #         extra = self.__fields__[name].field_info.extra\n        # pydantic v2\n        extra = self.model_fields[name].json_schema_extra\n\n        if extra and \"range\" in extra:\n            arg_is_list = isinstance(value, list)\n\n            if arg_is_list:\n                self.__iris__[name] = []\n                for e in value[:]:  # interate over copy of list\n                    if isinstance(e, BaseModel):  # contructed with object ref\n                        self.__iris__[name].append(e.get_iri())\n                    elif isinstance(e, str):  # constructed from json\n                        self.__iris__[name].append(e)\n                        value.remove(e)  # remove to construct valid instance\n                if len(value) == 0:\n                    # pydantic v1\n                    value = None  # else pydantic v1 will set a FieldInfo object\n                    # pydantic v2\n                    # del kw[name]\n            else:\n                if isinstance(value, BaseModel):  # contructed with object ref\n                    # print(value.id)\n                    self.__iris__[name] = value.get_iri()\n                elif isinstance(value, str):  # constructed from json\n                    self.__iris__[name] = value\n                    # pydantic v1\n                    value = None  # else pydantic v1 will set a FieldInfo object\n                    # pydantic v2\n                    # del kw[name]\n                elif value is None:\n                    del self.__iris__[name]\n        return value\n\n    def __setattr__(self, name, value, internal=False):\n        # print(\"__setattr__\", name, value)\n        if not internal and name not in [\n            \"__dict__\",\n            \"__pydantic_private__\",\n            \"__iris__\",\n        ]:\n            value = self._handle_value(name, value)\n\n        return super().__setattr__(name, value)\n\n    def __getattribute__(self, name):\n        # print(\"__getattribute__ \", name)\n        # async? https://stackoverflow.com/questions/33128325/\n        # how-to-set-class-attribute-with-await-in-init\n\n        if name in [\"__dict__\", \"__pydantic_private__\", \"__iris__\"]:\n            return BaseModel.__getattribute__(self, name)  # prevent loop\n\n        else:\n            if hasattr(self, \"__iris__\"):\n                if name in self.__iris__ and len(self.__iris__[name]) &gt; 0:\n                    if self.__dict__[name] is None or (\n                        isinstance(self.__dict__[name], list)\n                        and len(self.__dict__[name]) == 0\n                    ):\n                        iris = self.__iris__[name]\n                        is_list = isinstance(iris, list)\n                        if not is_list:\n                            iris = [iris]\n\n                        node_dict = self._resolve(iris)\n                        if is_list:\n                            node_list = []\n                            for iri in iris:\n                                node = node_dict[iri]\n                                node_list.append(node)\n                            self.__setattr__(name, node_list, True)\n                        else:\n                            node = node_dict[iris[0]]\n                            if node:\n                                self.__setattr__(name, node, True)\n\n        return BaseModel.__getattribute__(self, name)\n\n    def model_dump(self, **kwargs):  # extent BaseClass export function\n        # print(\"dict\")\n        remove_none = kwargs.get(\"exclude_none\", False)\n        kwargs[\"exclude_none\"] = False\n        d = super().model_dump(**kwargs)\n        # pprint(d)\n        self._object_to_iri(d)\n        if remove_none:\n            d = self.remove_none(d)\n        # pprint(d)\n        return d\n\n    @staticmethod\n    def _resolve(iris):\n        resolver = get_resolver(GetResolverParam(iri=iris[0])).resolver\n        node_dict = resolver.resolve(ResolveParam(iris=iris)).nodes\n        return node_dict\n\n    # pydantic v2\n    def model_dump_json(\n        self,\n        *,\n        indent: Union[int, None] = None,\n        include: Union[pydantic.main.IncEx, None] = None,\n        exclude: Union[pydantic.main.IncEx, None] = None,\n        context: Union[Any, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: Union[bool, Literal[\"none\", \"warn\", \"error\"]] = True,\n        serialize_as_any: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"Usage docs:\n        https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\n        Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n        Args:\n            indent: Indentation to use in the JSON output.\n                If None is passed, the output will be compact.\n            include: Field(s) to include in the JSON output.\n            exclude: Field(s) to exclude from the JSON output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to serialize using field aliases.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to\n                their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            round_trip: If True, dumped values should be valid as input\n                for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them,\n                True/\"warn\" logs errors, \"error\" raises a\n                [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization\n                behavior.\n\n        Returns:\n            A JSON string representation of the model.\n        \"\"\"\n        d = json.loads(\n            BaseModel.model_dump_json(\n                self,\n                indent=indent,\n                include=include,\n                exclude=exclude,\n                context=context,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=False,  # handle None values separately\n                round_trip=round_trip,\n                warnings=warnings,\n                serialize_as_any=serialize_as_any,\n            )\n        )  # ToDo directly use dict?\n        # this may replace some None values with IRIs in case they were never resolved\n        # thats why we handle exclude_none there\n        self._object_to_iri(d)\n        if exclude_none:\n            d = self.remove_none(d)\n        return json.dumps(d, **dumps_kwargs)\n\n    def to_jsonld(self) -&gt; Dict:\n        \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n        return export_jsonld(self, BaseModel)\n\n    @classmethod\n    def from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n        \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n        return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.from_jsonld","title":"<code>from_jsonld(jsonld)</code>  <code>classmethod</code>","text":"<p>Constructs a model instance from a JSON-LD representation.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>@classmethod\ndef from_jsonld(self, jsonld: Dict) -&gt; \"LinkedBaseModel\":\n    \"\"\"Constructs a model instance from a JSON-LD representation.\"\"\"\n    return import_jsonld(BaseModel, jsonld, _types)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.get_iri","title":"<code>get_iri()</code>","text":"<p>Return the unique IRI of the object. Overwrite this method in the subclass.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def get_iri(self) -&gt; str:\n    \"\"\"Return the unique IRI of the object.\n    Overwrite this method in the subclass.\"\"\"\n    return self.id\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.model_dump_json","title":"<code>model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, serialize_as_any=False, **dumps_kwargs)</code>","text":"<p>Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Args:     indent: Indentation to use in the JSON output.         If None is passed, the output will be compact.     include: Field(s) to include in the JSON output.     exclude: Field(s) to exclude from the JSON output.     context: Additional context to pass to the serializer.     by_alias: Whether to serialize using field aliases.     exclude_unset: Whether to exclude fields that have not been explicitly set.     exclude_defaults: Whether to exclude fields that are set to         their default value.     exclude_none: Whether to exclude fields that have a value of <code>None</code>.     round_trip: If True, dumped values should be valid as input         for non-idempotent types such as Json[T].     warnings: How to handle serialization errors. False/\"none\" ignores them,         True/\"warn\" logs errors, \"error\" raises a         [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError].     serialize_as_any: Whether to serialize fields with duck-typing serialization         behavior.</p> <p>Returns:     A JSON string representation of the model.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: Union[int, None] = None,\n    include: Union[pydantic.main.IncEx, None] = None,\n    exclude: Union[pydantic.main.IncEx, None] = None,\n    context: Union[Any, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    warnings: Union[bool, Literal[\"none\", \"warn\", \"error\"]] = True,\n    serialize_as_any: bool = False,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"Usage docs:\n    https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output.\n            If None is passed, the output will be compact.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to\n            their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        round_trip: If True, dumped values should be valid as input\n            for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them,\n            True/\"warn\" logs errors, \"error\" raises a\n            [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        serialize_as_any: Whether to serialize fields with duck-typing serialization\n            behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    d = json.loads(\n        BaseModel.model_dump_json(\n            self,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            context=context,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=False,  # handle None values separately\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n        )\n    )  # ToDo directly use dict?\n    # this may replace some None values with IRIs in case they were never resolved\n    # thats why we handle exclude_none there\n    self._object_to_iri(d)\n    if exclude_none:\n        d = self.remove_none(d)\n    return json.dumps(d, **dumps_kwargs)\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.model_validate","title":"<code>model_validate(obj, *, strict=None, from_attributes=None, context=None)</code>  <code>classmethod</code>","text":"<p>Validate a pydantic model instance.</p> <p>Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     from_attributes: Whether to extract data from object attributes.     context: Additional context to pass to the validator.</p> <p>Raises:     ValidationError: If the object could not be validated.</p> <p>Returns:     The validated model instance.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: Union[bool, None] = None,\n    from_attributes: Union[bool, None] = None,\n    context: Union[Any, None] = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    if isinstance(obj, str):\n        return cls._resolve([obj])[obj]\n    if isinstance(obj, list):\n        node_dict = cls._resolve(obj)\n        node_list = []\n        for iri in obj:\n            node = node_dict[iri]\n            if node:\n                node_list.append(node)\n        return node_list\n    elif isinstance(obj, dict):\n        super().model_validate(\n            obj, strict=strict, from_attributes=from_attributes, context=context\n        )\n</code></pre>"},{"location":"oold/#oold.model.LinkedBaseModel.to_jsonld","title":"<code>to_jsonld()</code>","text":"<p>Return the RDF representation of the object as JSON-LD.</p> Source code in <code>src/oold/model/__init__.py</code> <pre><code>def to_jsonld(self) -&gt; Dict:\n    \"\"\"Return the RDF representation of the object as JSON-LD.\"\"\"\n    return export_jsonld(self, BaseModel)\n</code></pre>"}]}